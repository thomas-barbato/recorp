<!-- Ultimate Warp Loader — Smooth Zoom + Depth + Ray Halo -->
<style>
#sector-loader-canvas-container {
  position: fixed; inset: 0; z-index: 9999;
  display: none; pointer-events: none;
  opacity: 0; transition: opacity 0.8s ease;
  background: radial-gradient(circle at center, #020318 0%, #00040a 50%, #000001 100%);
}
#sector-loader-canvas { width: 100%; height: 100%; display: block; }
.loader-text {
  position: absolute; bottom: 6%; left: 50%; transform: translateX(-50%);
  font-family: Inter, Roboto, system-ui, -apple-system, "Segoe UI", Arial;
  color: #9fcfff; font-weight: 600; letter-spacing: 0.06em;
  font-size: clamp(12px,1.6vw,18px);
  text-shadow: 0 2px 10px rgba(0,0,0,0.8);
  user-select: none; pointer-events: none; white-space: pre;
  transition: opacity 0.8s ease;
}
@keyframes dots {
  0%{content:""} 25%{content:"."} 50%{content:".."} 75%{content:"..."} 100%{content:""}
}
.loader-dots::after { content:""; animation:dots 1.2s steps(4,end) infinite; }
</style>

<div id="sector-loader-canvas-container">
  <canvas id="sector-loader-canvas"></canvas>
  <div id="sector-loader-text" class="loader-text">Voyage en cours<span class="loader-dots"></span></div>
</div>

<script>
(function(){
const container = document.getElementById('sector-loader-canvas-container');
const canvas = document.getElementById('sector-loader-canvas');
const ctx = canvas.getContext('2d');

let width, height, centerX, centerY, maxDist;
let animationId = null;
const rayCount = 220;
const rays = [];

function resizeCanvas(){
  width = container.clientWidth;
  height = container.clientHeight;
  canvas.width = width;
  canvas.height = height;
  centerX = width/2;
  centerY = height/2;
  maxDist = Math.sqrt(centerX*centerX + centerY*centerY);
}

function initRays(){
  rays.length = 0;
  for(let i=0;i<rayCount;i++){
    const angle = Math.random()*2*Math.PI;
    const distance = maxDist*(0.2 + Math.random()*0.8); // distance initiale varie
    const speed = 0.5 + Math.random()*3.0; // vitesse variable
    const widthRay = 0.7 + Math.random()*1.3;
    const opacity = 0.3 + Math.random()*0.7;
    rays.push({angle,distance,speed,width:widthRay,opacity});
  }
}

let zoomFactor = 0;
let zoomSpeed = 0;

function draw(){
  ctx.clearRect(0,0,width,height);

  const brightness = 1 - zoomFactor*0.6;
  const bgGrad = ctx.createRadialGradient(centerX,centerY,0,centerX,centerY,Math.max(width,height)/2);
  const baseR = Math.floor(5*brightness);
  const baseG = Math.floor(10*brightness);
  const baseB = Math.floor(35+40*brightness);
  bgGrad.addColorStop(0,`rgb(${baseR},${baseG},${baseB})`);
  bgGrad.addColorStop(0.6,`rgb(0,${Math.floor(10*brightness)},${Math.floor(40+40*brightness)})`);
  bgGrad.addColorStop(1,`rgb(0,0,0)`);
  ctx.fillStyle = bgGrad;
  ctx.fillRect(0,0,width,height);

  ctx.save();
  ctx.translate(centerX,centerY);

  // --- Zoom fluide ---
  const t = Date.now()*0.0015;
  zoomFactor = (Math.sin(t)*0.5 + 0.5)*0.8;
  zoomSpeed = Math.abs(Math.cos(t)*0.5*0.8);
  ctx.scale(1+zoomFactor*0.1,1+zoomFactor*0.1);

  // --- Halo central pulsant ---
  const pulse = 0.5 + 0.5*Math.sin(Date.now()/700);
  const reactivePulse = pulse + zoomSpeed*1.8;
  const haloRadius = 80 + 40*reactivePulse;
  const haloGrad = ctx.createRadialGradient(0,0,0,0,0,haloRadius);
  const haloAlpha = 0.25 + 0.25*reactivePulse;
  haloGrad.addColorStop(0,`rgba(180,230,255,${haloAlpha})`);
  haloGrad.addColorStop(0.4,`rgba(140,200,255,${haloAlpha*0.6})`);
  haloGrad.addColorStop(1,'rgba(0,0,0,0)');
  ctx.beginPath();
  ctx.fillStyle = haloGrad;
  ctx.arc(0,0,haloRadius,0,Math.PI*2);
  ctx.fill();

  // --- Rayons bleus avec profondeur et halo lumineux ---
  rays.forEach(r=>{
    const distortion = 2*Math.sin(Date.now()/700 + r.distance/100);
    const x = Math.cos(r.angle)*(r.distance + distortion);
    const y = Math.sin(r.angle)*(r.distance + distortion);
    const len = r.distance*0.15 + 10;

    const t = Math.min(r.distance/maxDist,1);
    const rCol = Math.floor(150 + (200-150)*(1-t));
    const gCol = Math.floor(200 + (255-200)*(1-t));
    const bCol = Math.floor(255 - 20*t);
    ctx.strokeStyle = `rgba(${rCol},${gCol},${bCol},${r.opacity})`;
    ctx.lineWidth = r.width;

    // Rayons principaux
    ctx.beginPath();
    ctx.moveTo(x,y);
    ctx.lineTo(x*0.85, y*0.85);
    ctx.stroke();

    // Halo lumineux autour des rayons proches
    if(t < 0.5){ // seuls les rayons proches ont halo
      const halo = ctx.createRadialGradient(x*0.85, y*0.85, 0, x*0.85, y*0.85, r.width*4);
      halo.addColorStop(0, `rgba(180,230,255,${r.opacity*0.4})`);
      halo.addColorStop(1, 'rgba(180,230,255,0)');
      ctx.fillStyle = halo;
      ctx.beginPath();
      ctx.arc(x*0.85, y*0.85, r.width*4,0,Math.PI*2);
      ctx.fill();
    }

    // Vitesse variable selon distance → effet profondeur
    r.distance -= r.speed*(0.5 + 0.5*(1-t));
    if(r.distance<0){
      r.distance = maxDist;
      r.angle = Math.random()*2*Math.PI;
      r.speed = 0.5 + Math.random()*3.0;
      r.width = 0.7 + Math.random()*1.3;
      r.opacity = 0.3 + Math.random()*0.7;
    }
  });

  ctx.restore();
  animationId = requestAnimationFrame(draw);
}

window.addEventListener('resize',resizeCanvas);

window.showLoader = function(){
  container.style.display='block';
  requestAnimationFrame(()=>{
    container.style.opacity=1;
    container.querySelector('.loader-text').style.opacity=1;
  });
  resizeCanvas();
  initRays();
  if(animationId) cancelAnimationFrame(animationId);
  draw();
}

window.hideLoader = function(){
  container.style.opacity=0;
  container.querySelector('.loader-text').style.opacity=0;
  setTimeout(()=>{
    container.style.display='none';
    if(animationId) cancelAnimationFrame(animationId);
  },800);
}

window.setLoaderText = function(text){
  const textNode = container.querySelector('#sector-loader-text').firstChild;
  if(textNode.nodeType===Node.TEXT_NODE) textNode.textContent = text||'';
}
})();

window.showLoader();
</script>
